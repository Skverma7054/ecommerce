const express = require('express');
const crypto = require('crypto');
const Razorpay = require('razorpay');
const Order = require('../models/Order');

const router = express.Router();

const razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID,
  key_secret: process.env.RAZORPAY_KEY_SECRET,
});

// POST /api/payments/create-order
// Creates a Razorpay order that will be used by the Checkout on the frontend.
router.post('/create-order', async (req, res) => {
  try {
    const { totalAmount, currency = 'INR', orderId } = req.body;

    if (!totalAmount || Number.isNaN(Number(totalAmount))) {
      return res.status(400).json({ message: 'totalAmount is required and must be a number.' });
    }

    // Razorpay expects amount in the smallest currency unit (paise for INR).
    const amountInPaise = Math.round(Number(totalAmount) * 100);

    const razorpayOrder = await razorpay.orders.create({
      amount: amountInPaise,
      currency,
      receipt: `receipt_${Date.now()}`,
      payment_capture: 1,
    });

    // Update an existing order, or create a placeholder order for learning/testing.
    let order = null;
    if (orderId) {
      order = await Order.findById(orderId);
    }

    if (!order) {
      order = await Order.create({
        customerName: 'Guest',
        items: [],
        totalAmount: Number(totalAmount),
        currency,
      });
    }

    order.razorpayOrderId = razorpayOrder.id;
    order.paymentStatus = 'created';
    await order.save();

    // Return the minimal data that the frontend needs to open Razorpay Checkout.
    return res.status(201).json({
      orderId: razorpayOrder.id,
      amount: razorpayOrder.amount,
      currency: razorpayOrder.currency,
      dbOrderId: order._id,
    });
  } catch (error) {
    return res.status(500).json({ message: 'Failed to create Razorpay order.', error: error.message });
  }
});

// POST /api/payments/verify
// Verifies the payment signature returned by Razorpay Checkout.
// Signature verification ensures the payment details were not tampered with.
router.post('/verify', async (req, res) => {
  try {
    const { razorpay_order_id, razorpay_payment_id, razorpay_signature, orderId } = req.body;

    if (!razorpay_order_id || !razorpay_payment_id || !razorpay_signature) {
      return res.status(400).json({ message: 'Missing Razorpay payment details.' });
    }

    // The signature is an HMAC-SHA256 hash generated by Razorpay.
    // We recompute it on the server using the secret key and compare values.
    const expectedSignature = crypto
      .createHmac('sha256', process.env.RAZORPAY_KEY_SECRET)
      .update(`${razorpay_order_id}|${razorpay_payment_id}`)
      .digest('hex');

    if (expectedSignature !== razorpay_signature) {
      return res.status(400).json({ message: 'Invalid signature. Payment verification failed.' });
    }

    const order = await Order.findById(orderId);
    if (!order) {
      return res.status(404).json({ message: 'Order not found for verification.' });
    }

    order.razorpayPaymentId = razorpay_payment_id;
    order.paymentStatus = 'paid';
    order.paymentMethod = 'razorpay';
    await order.save();

    return res.status(200).json({ message: 'Payment verified successfully.', order });
  } catch (error) {
    return res.status(500).json({ message: 'Payment verification failed.', error: error.message });
  }
});

// POST /api/payments/webhook
// Handles Razorpay webhook events (e.g., payment.captured, payment.failed).
// Razorpay signs each webhook, so we verify the signature with the webhook secret.
router.post('/webhook', async (req, res) => {
  try {
    const webhookSecret = process.env.RAZORPAY_WEBHOOK_SECRET;

    if (!webhookSecret) {
      return res.status(500).json({ message: 'Webhook secret is not configured.' });
    }

    const razorpaySignature = req.headers['x-razorpay-signature'];
    const expectedSignature = crypto
      .createHmac('sha256', webhookSecret)
      .update(req.body)
      .digest('hex');

    if (expectedSignature !== razorpaySignature) {
      return res.status(400).json({ message: 'Invalid webhook signature.' });
    }

    const payload = JSON.parse(req.body.toString());
    const event = payload.event;

    if (event === 'payment.captured') {
      const paymentEntity = payload.payload.payment.entity;
      const orderId = paymentEntity.order_id;

      await Order.findOneAndUpdate(
        { razorpayOrderId: orderId },
        {
          razorpayPaymentId: paymentEntity.id,
          paymentStatus: 'paid',
          paymentMethod: paymentEntity.method,
        },
        { new: true }
      );
    }

    if (event === 'payment.failed') {
      const paymentEntity = payload.payload.payment.entity;
      const orderId = paymentEntity.order_id;

      await Order.findOneAndUpdate(
        { razorpayOrderId: orderId },
        {
          razorpayPaymentId: paymentEntity.id,
          paymentStatus: 'failed',
          paymentMethod: paymentEntity.method,
        },
        { new: true }
      );
    }

    return res.status(200).json({ status: 'ok' });
  } catch (error) {
    return res.status(500).json({ message: 'Webhook handler failed.', error: error.message });
  }
});

module.exports = router;
